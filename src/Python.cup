//package src;

import java_cup.runtime.*;
import java.util.*;

parser code {:
    // Error handling methods
    public void report_error(String message, Object info) {
        StringBuilder errorMsg = new StringBuilder("Error: " + message);
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
            if (s.left >= 0) {
                errorMsg.append(" at line " + (s.left + 1));
                if (s.right >= 0) {
                    errorMsg.append(", column " + (s.right + 1));
                }
            }
        }
        syntaxErrors.add(errorMsg.toString());
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    // Symbol table and type checking
    private SymbolTable symbolTable = new SymbolTable();
    private List<String> syntaxErrors = new ArrayList<>();
    private List<String> semanticErrors = new ArrayList<>();
    
    public List<String> getSyntaxErrors() {
        return syntaxErrors;
    }
    
    public List<String> getSemanticErrors() {
        return semanticErrors;
    }
    
    // Add semantic error
    public void addSemanticError(String message, int line, int column) {
        semanticErrors.add("Error at line " + line + ", column " + column + ": " + message);
    }
    
    // Check indentation
    private int expectedIndent = 0;
    private Stack<Integer> indentStack = new Stack<>();
    
    public void checkIndentation(int spaces, int line) {
        if (spaces % 4 != 0) {
            semanticErrors.add("Error at line " + line + ": Indentation should be a multiple of 4 spaces");
        }
        
        int level = spaces / 4;
        if (level > expectedIndent) {
            // Indent should only increase by 1 level at a time
            if (level != expectedIndent + 1) {
                semanticErrors.add("Error at line " + line + ": Indentation increased by more than one level");
            }
            indentStack.push(expectedIndent);
            expectedIndent = level;
        } else if (level < expectedIndent) {
            // Check if dedent goes back to a valid level
            boolean validDedent = false;
            while (!indentStack.isEmpty()) {
                int prevIndent = indentStack.pop();
                if (prevIndent == level) {
                    validDedent = true;
                    break;
                }
            }
            if (!validDedent) {
                semanticErrors.add("Error at line " + line + ": Invalid dedent level");
            }
            expectedIndent = level;
        }
    }
:}

// Terminal symbols (tokens)
terminal PLUS, MINUS, TIMES, DIVIDE, MODULO, POWER;
terminal ASSIGN, EQUALS, NOT_EQUALS, LESS, GREATER, LESS_EQUALS, GREATER_EQUALS;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal COMMA, COLON, DOT, SEMICOLON;
terminal AND, OR, NOT, IF, ELIF, ELSE, WHILE, FOR, IN, DEF, RETURN, CLASS;
terminal INDENT, DEDENT, NEWLINE;
terminal Integer INTEGER;
terminal Float FLOAT;
terminal String STRING, IDENTIFIER;
terminal Boolean BOOLEAN;
terminal COMMENT;

// Non-terminal symbols
non terminal program, stmts, stmt;
non terminal expr, term, factor, atom;
non terminal if_stmt, while_stmt, for_stmt, compound_stmt;
non terminal expr_list, param_list;
non terminal PythonSymbol expr_with_type, term_with_type, factor_with_type, atom_with_type;

// Precedence declarations
precedence left OR;
precedence left AND;
precedence left EQUALS, NOT_EQUALS;
precedence left LESS, GREATER, LESS_EQUALS, GREATER_EQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence right POWER;
precedence right NOT;

// Grammar rules with semantic actions
program ::= stmts;

stmts ::= stmt
        | stmts stmt;

stmt ::= expr NEWLINE
       | IDENTIFIER:id ASSIGN expr_with_type:e NEWLINE {: 
           symbolTable.put(id, e.type); 
       :}
       | compound_stmt;

compound_stmt ::= if_stmt
                | while_stmt
                | for_stmt;

if_stmt ::= IF expr COLON NEWLINE INDENT stmts DEDENT
          | IF expr COLON NEWLINE INDENT stmts DEDENT ELSE COLON NEWLINE INDENT stmts DEDENT;

while_stmt ::= WHILE expr COLON NEWLINE INDENT stmts DEDENT;

for_stmt ::= FOR IDENTIFIER IN expr COLON NEWLINE INDENT stmts DEDENT;

expr_with_type ::= term_with_type:t {: RESULT = t; :}
                 | expr_with_type:e1 PLUS term_with_type:e2 {: 
                     if (!e1.type.isCompatible(e2.type)) {
                         parser.addSemanticError("Type mismatch: cannot add " + e1.type + " and " + e2.type, e1.line, e1.column);
                         RESULT = new PythonSymbol(e1.value + "+" + e2.value, new Type("error"), e1.line, e1.column);
                     } else {
                         Type resultType = e1.type.getResultType(e2.type, "+");
                         RESULT = new PythonSymbol(e1.value + "+" + e2.value, resultType, e1.line, e1.column);
                     }
                  :}
                 | expr_with_type:e1 MINUS term_with_type:e2 {: 
                     if (!e1.type.isCompatible(e2.type)) {
                         parser.addSemanticError("Type mismatch: cannot subtract " + e2.type + " from " + e1.type, e1.line, e1.column);
                         RESULT = new PythonSymbol(e1.value + "-" + e2.value, new Type("error"), e1.line, e1.column);
                     } else {
                         Type resultType = e1.type.getResultType(e2.type, "-");
                         RESULT = new PythonSymbol(e1.value + "-" + e2.value, resultType, e1.line, e1.column);
                     }
                  :};

term_with_type ::= factor_with_type:f {: RESULT = f; :}
                 | term_with_type:t1 TIMES factor_with_type:t2 {: 
                     if (!t1.type.isCompatible(t2.type)) {
                         parser.addSemanticError("Type mismatch: cannot multiply " + t1.type + " and " + t2.type, t1.line, t1.column);
                         RESULT = new PythonSymbol(t1.value + "*" + t2.value, new Type("error"), t1.line, t1.column);
                     } else {
                         Type resultType = t1.type.getResultType(t2.type, "*");
                         RESULT = new PythonSymbol(t1.value + "*" + t2.value, resultType, t1.line, t1.column);
                     }
                  :}
                 | term_with_type:t1 DIVIDE factor_with_type:t2 {: 
                     if (!t1.type.isCompatible(t2.type)) {
                         parser.addSemanticError("Type mismatch: cannot divide " + t1.type + " by " + t2.type, t1.line, t1.column);
                         RESULT = new PythonSymbol(t1.value + "/" + t2.value, new Type("error"), t1.line, t1.column);
                     } else {
                         Type resultType = t1.type.getResultType(t2.type, "/");
                         RESULT = new PythonSymbol(t1.value + "/" + t2.value, resultType, t1.line, t1.column);
                     }
                  :}
                 | term_with_type:t1 MODULO factor_with_type:t2 {: 
                     if (!t1.type.isCompatible(t2.type)) {
                         parser.addSemanticError("Type mismatch: cannot calculate modulo of " + t1.type + " and " + t2.type, t1.line, t1.column);
                         RESULT = new PythonSymbol(t1.value + "%" + t2.value, new Type("error"), t1.line, t1.column);
                     } else {
                         Type resultType = t1.type.getResultType(t2.type, "%");
                         RESULT = new PythonSymbol(t1.value + "%" + t2.value, resultType, t1.line, t1.column);
                     }
                  :};

factor_with_type ::= atom_with_type:a {: RESULT = a; :}
                   | factor_with_type:f POWER atom_with_type:a {: 
                       if (!f.type.isCompatible(a.type)) {
                           parser.addSemanticError("Type mismatch: cannot raise " + f.type + " to power of " + a.type, f.line, f.column);
                           RESULT = new PythonSymbol(f.value + "**" + a.value, new Type("error"), f.line, f.column);
                       } else {
                           Type resultType = f.type.getResultType(a.type, "**");
                           RESULT = new PythonSymbol(f.value + "**" + a.value, resultType, f.line, f.column);
                       }
                    :};

atom_with_type ::= INTEGER:i {: RESULT = new PythonSymbol(i, new Type("int"), ileft, iright); :}
                 | FLOAT:f {: RESULT = new PythonSymbol(f, new Type("float"), fleft, fright); :}
                 | STRING:s {: RESULT = new PythonSymbol(s, new Type("string"), sleft, sright); :}
                 | BOOLEAN:b {: RESULT = new PythonSymbol(b, new Type("boolean"), bleft, bright); :}
                 | IDENTIFIER:id {: 
                     Type type = symbolTable.get(id);
                     if (type == null) {
                         parser.addSemanticError("Undefined variable: " + id, idleft, idright);
                         RESULT = new PythonSymbol(id, new Type("unknown"), idleft, idright);
                     } else {
                         RESULT = new PythonSymbol(id, type, idleft, idright);
                     }
                  :}
                 | LPAREN expr_with_type:e RPAREN {: RESULT = e; :};

expr ::= expr_with_type;

expr_list ::= expr
            | expr_list COMMA expr;

param_list ::= IDENTIFIER
             | param_list COMMA IDENTIFIER;
